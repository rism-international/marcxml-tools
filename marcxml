#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'nokogiri'
require 'trollop'
require 'ruby-progressbar'
require 'rbconfig'
require 'zip'
require 'pry'
Dir[File.dirname(__FILE__) + '/lib/*.rb'].each {|file| require file }

NAMESPACE={'marc' => "http://www.loc.gov/MARC21/slim"}
ZR_ADDITION=true

#OPTIONS
opts = Trollop::options do
  version "RISM Marcxml changer 1.0"
  banner <<-EOS
This utility program changes MARCXML nodes according to an YAML file.

Usage:
   marcxml [options]
where [options] are:
  EOS
  opt :config, "YAML-file with transforming rules", :type => :string, :default => "conf/transform.yaml", :short => "-c"
  opt :infile, "Input-Filename", :type => :strings, :short => "-i"
  opt :outfile, "Output-Filename", :type => :string, :default => "out.xml", :short => '-o'
  opt :transform, "Transform Marcxml", :short => '-t'
  opt :analyze, "Analyze Marcxml", :short => '-a'
  opt :filter, "Filter Marcxml", :short => '-f'
  opt :merge, "Merge Marcxml", :short => '-m'
  opt :report, "Generate Report", :short => '-r'
  opt :split, "Split Marcxml", :short => '-s'
  opt :validate, "Validate Marcxml", :short => '-d'
  opt "with-content", "with sample content (only with analyze)"
  opt "with-linked", "with linked entries (only with filter)", :type => :string
  opt :xor, "With or logic (only with filter)"
  opt :zip, "Create output as zip"
  opt :limit, "Limit size of output", :short => '-l', :type => :integer, :default => 50000

end

Trollop::die :infile, "must exist" if !opts[:infile]

if opts[:infile].size == 1
  source_file = opts[:infile].first
else
  source_files = opts[:infile]
end

ofile=File.open(opts[:outfile], "w")
if source_file
  total = ApplicationHelper.total(source_file)
else
  total = 10000
end

if opts['with-linked']
  total = total * 2
end

bar = ProgressBar.create(title: "Found", :format => "%c of %C Records transformed. -- %a | %B | %p%% %e", total: total, remainder_mark: '-', progress_mark: '#') unless opts[:merge]

if (source_file && File.exists?(source_file)) || source_files
  #Setting runtime variables
  if opts[:transform]
    transform=YAML.load_file(opts[:config])
    transform_class = transform['Class'] ? Object.const_get(transform['Class']) : Transformator
    Transformator.mapping = transform['Mapping']
  elsif opts[:analyze]
    resdict=Hash.new(0)
    content_dict={}
  elsif opts[:filter]
    filter_class = Marcxml::Filter
    filter_class.config = YAML.load_file(opts[:config])
    filter_class.connected = opts['with-linked']
    filter_class.xor = opts[:xor]
  elsif opts[:split]
    start = 0
    ofile=File.open("#{"%06d" % start}.xml", "w")

  elsif opts[:merge]
    xmlstream = Xmlstream.new(ofile)
    source_files.each do |sfile|
      puts sfile
      if File.exists?(sfile)
        xmlstream.each_record(sfile) { |record|
          xmlstream.write(record)
        }
      end
    end
    xmlstream.close
    puts "Finished."
    exit
  end


  #Start reading stream
  xmlstream = Xmlstream.new(ofile)
  xmlstream.each_record(source_file) do |record|

    if opts[:transform]
      tr = transform_class.new(record)
      if ZR_ADDITION
        tr.execute_all
      end
      if tr.namespace
        nodes = record.xpath("//marc:datafield", NAMESPACE).remove
        xmlstream.append(record, nodes)
      end
    elsif opts[:filter]
      filter = filter_class.new(record)
      xmlstream.write(record) if filter.match?  

    elsif opts[:split]
      doc = Nokogiri::XML.parse(record.to_s) do |config|
        config.noblanks
      end
      ofile.write(doc.remove_namespaces!.root.to_xml :encoding => 'UTF-8')
      start+=1
      if start % opts[:limit] == 0
        ofile.write("</collection>")
        ofile.close
        ofile=File.open("#{"%06d" % start}.xml", "w")
        ofile.write('<?xml version="1.0" encoding="UTF-8"?>'+"\n"+'<collection xmlns="http://www.loc.gov/MARC21/slim">'+"\n")
      end
    #break if start==100

    elsif opts[:analyze]
      record.xpath('//marc:controlfield', NAMESPACE).each do |node|
        resdict[node["tag"]]+=1
        if opts["with-content"] && !content_dict.has_key?(node["tag"])
          content_dict[node["tag"]]=node.content
        end
      end
      record.xpath('//marc:datafield', NAMESPACE).each do |node|
        if node.children
          node.children.each do |sf|
            if sf["code"]
              resdict["#{node["tag"]}$#{sf["code"]}"]+=1
              if opts["with-content"] && !content_dict.has_key?("#{node["tag"]}$#{sf["code"]}")
                content_dict["#{node["tag"]}$#{sf["code"]}"]=sf.content
              end
            end
          end
        end
      end
    end
    bar.increment
  end
  
  if opts['with-linked']
    individuals=(filter_class.connected_records - filter_class.result_records).uniq
    xmlstream.each_record(source_file) do |record|
      id=record.xpath('//marc:controlfield[@tag="001"]', NAMESPACE)[0].content 
      if individuals.include?(id)
        xmlstream.write(record)
      end
      bar.increment
    end
  end
  

  #Writing to outfile
  ##TODO making writer generic
  if opts[:analyze]
    if opts["with-content"]
      resdict.each do |k,v|
      resdict[k]=v.to_s + " (#{content_dict[k]})"
      end
    end
    if ofile
      ofile.write(Hash[*(resdict.sort_by{|k,v| k}).flatten].to_yaml)
      ofile.close
    else
      puts Hash[*(resdict.sort_by{|k,v| k}).flatten].to_yaml
    end
    puts "\nCompleted!"
  elsif opts[:split]
    ofile.write("\n</collection>")
    ofile.close
    puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")
  else
    xmlstream.close
    puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")
  end
else
  puts source_file + " is not a file!"
end

#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'nokogiri'
require 'trollop'
require 'ruby-progressbar'
require 'rbconfig'
require 'zip'
require 'pry'
require_relative 'lib/transformator'
require_relative 'lib/xmlstream'
require_relative 'lib/marc_string'

NAMESPACE={'marc' => "http://www.loc.gov/MARC21/slim"}
ZR_ADDITION=true

#OPTIONS
opts = Trollop::options do
  version "RISM changer 1.0"
  banner <<-EOS
This utility program changes MARCXML nodes according to an YAML file.

Usage:
   marcxml-transform [options]
where [options] are:
  EOS
  opt :rules, "YAML-file with transforming rules", :type => :string, :default => "conf/transform.yaml"
  opt :infile, "Input-Filename", :type => :string
  opt :outfile, "Output-Filename", :type => :string, :default => "out.xml"
end

Trollop::die :infile, "must exist" if !opts[:infile]
source_file=opts[:infile]
transform=YAML.load_file(opts[:rules])
start = 0
ofile=File.open(opts[:outfile], "w")
print transform

if File.exists?(source_file)
  xmlstream = Xmlstream.new(ofile)
  xmlstream.each_record(source_file) do |record|
    delete_flag=false
    tr = Transformator.new(record)
    tr.change_leader
    tr.change_material
    tr.change_collection
    if ZR_ADDITION
      tr.zr_addition_change_attribution
      tr.zr_addition_prefix_performance
      tr.zr_addition_split_730
      tr.zr_addition_add_isil
      tr.zr_addition_change_593_abbreviation
      tr.delete_anonymus
    end

    transform.each do |entry| 
      entry.each do |k,v|
        # Delete if node not exits
        if !v
          tag=k.split("$")[0]
          code=k.split("$")[1]
          node=record.xpath("//marc:datafield[@tag='#{tag}']", NAMESPACE)
          subfield_node=record.xpath("//marc:datafield[@tag='#{tag}']/marc:subfield[@code='#{code}']", NAMESPACE)
          if node.empty? || subfield_node.empty? || subfield_node.text.strip.empty?
            puts record
            delete_flag=true            
          end
          next if delete_flag
        elsif v=="-"
          tr.remove_subfield(k)
        # Rename datafield
        elsif k.is_tag? && v.is_tag?
          tr.rename_datafield(k, v)
        # Rename subfield
        elsif k.is_tag_with_subfield? && v.is_subfield?
          tag=k.split("$")[0]
          old_sf=k.split("$")[1]
          new_sf=v
          tr.rename_subfield_code(tag, old_sf, new_sf)
        # Move subfield
        elsif k.is_tag_with_subfield? && v.is_tag?
          tr.move_subfield_to_tag(k, v)
        end


      end


    end


    #    if transform["change content"]
    #      transform['change content'].keys.each do |tags|
    #          tag=tags.split("$")[0]
    #          code=tags.split("$")[1]
    #          replacements=transform['change content'][tags]
    #          tr.change_content(code, replacements)
    #      end
    #    end
    #Sorting tags
    unless delete_flag
      nodes = record.xpath("//marc:datafield", NAMESPACE).remove
      xmlstream.append(record, nodes)
    end
  end
  xmlstream.close
  puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")
else
  puts source_file + " is not a file!"
end

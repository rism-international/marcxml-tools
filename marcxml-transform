#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'nokogiri'
require 'trollop'
require 'ruby-progressbar'
require 'rbconfig'
require 'zip'

NAMESPACE={'marc' => "http://www.loc.gov/MARC21/slim"}

#OPTIONS
opts = Trollop::options do
  version "RISM changer 1.0"
  banner <<-EOS
This utility program changes MARCXML nodes according to an YAML file.

Usage:
   marcxml-transform [options]
where [options] are:
  EOS
  opt :rules, "YAML-file with transforming rules", :type => :string, :default => "transform.yaml"
  opt :infile, "Input-Filename", :type => :string
  opt :outfile, "Output-Filename", :type => :string, :default => "out.xml"
end

Trollop::die :infile, "must exist" if !opts[:infile]
source_file=opts[:infile]
transform=YAML.load_file(opts[:rules])

def rename_subfield_code(node, tag, old_code, new_code)
  subfield=node.xpath("//marc:datafield[@tag='#{tag}']/marc:subfield[@code='#{old_code}']", NAMESPACE)
  if !node.xpath("//marc:datafield[@tag='#{tag}']/marc:subfield[@code='#{new_code}']", NAMESPACE).empty?
    puts "WARNING: #{tag}$#{new_code} already exits!"
  end
  subfield.attr('code', new_code) if subfield
  subfield
end

def move_subfield_to_tag(node, from_tag, tag)
  ftag=from_tag.split("$")[0]
  fcode=from_tag.split("$")[1]
  target=node.xpath("//marc:datafield[@tag='#{tag}']", NAMESPACE)
  source=node.xpath("//marc:datafield[@tag='#{ftag}']/marc:subfield[@code='#{fcode}']", NAMESPACE)

  target.children.first.add_previous_sibling(source)
  if node.xpath("//marc:datafield[@tag='#{ftag}']/marc:subfield[@code='*']", NAMESPACE).empty?
    node.xpath("//marc:datafield[@tag='#{ftag}']", NAMESPACE).remove
  end
  target
end

def change_leader(node)
  leader=node.xpath("//marc:leader", NAMESPACE)[0]
  if leader
    leader.content="00000ccm a2200000   4500"
  else
    leader = Nokogiri::XML::Node.new "leader", node
    leader.content="00000ccm a2200000   4500"
    node.root.children.first.add_previous_sibling(leader)
  end
  leader
end

def rename_datafield(node, tag, new_tag)
  if !node.xpath("//marc:datafield[@tag='#{new_tag}']", NAMESPACE).empty?
    puts "WARNING: Tag #{new_tag} already exits!"
  end
  datafield=node.xpath("//marc:datafield[@tag='#{tag}']", NAMESPACE)
  datafield.attr('tag', new_tag) if datafield
  datafield
end

def change_collection(node)
  subfield=node.xpath("//marc:datafield[@tag='100']/marc:subfield[@code='a']", NAMESPACE)
  if subfield.text=='Collection'
    node.xpath("//marc:datafield[@tag='100']", NAMESPACE).remove
    change_datafield(node, '240', '110')
  end
end

def change_material(node)
  materials=node.xpath("//marc:datafield/marc:subfield[@code='8']", NAMESPACE)
  materials.each do |material|
    material.content="%02d" % material.content.gsub("\\c", "") if material
  end
end


#Helper method to parse huge files with nokogiri
def each_record(filename, &block)
  File.open(filename) do |file|
    Nokogiri::XML::Reader.from_io(file).each do |node|
      if node.name == 'record' and node.node_type == Nokogiri::XML::Reader::TYPE_ELEMENT
        yield(Nokogiri::XML(node.outer_xml, nil, "UTF-8"))
      end
    end
  end
end



start = 0
ofile=File.open(opts[:outfile], "w")
ofile.write('<?xml version="1.0" encoding="UTF-8"?>'+"\n"+'<collection xmlns="http://www.loc.gov/MARC21/slim">'+"\n")
if File.exists?(source_file)
  each_record(source_file) { |record|
    change_leader(record)
    change_material(record)
    change_collection(record)
    transform['rename datafields'].each do |tags|
      tags.each do |k,v|
        rename_datafield(record, k, v)
      end
    end
    transform['rename subfields'].each do |tags|
      tags.each do |k,v|
        tag=k.split("$")[0]
        old_sf=k.split("$")[1]
        new_sf=v
        rename_subfield_code(record, tag, old_sf, new_sf)
      end
    end
    transform['move subfields'].each do |tags|
      tags.each do |k,v|
        move_subfield_to_tag(record, k, v)
      end
    end
    #Sorting tags
    nodes = record.xpath("//marc:datafield", NAMESPACE).remove
    nodes.sort_by{|node| node.attr("tag")}.each{|node| 
      record.root.add_child(node)}
    doc = Nokogiri::XML.parse(record.to_s) do |config|
      config.noblanks
    end

    ofile.write(doc.remove_namespaces!.root.to_xml :encoding => 'UTF-8')
    start+=1
    puts start
  }
  ofile.write("\n</collection>")
  ofile.close
  puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")

else
  puts source_file + " is not a file!"
end

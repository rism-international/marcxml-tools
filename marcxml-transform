#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'nokogiri'
require 'trollop'
require 'ruby-progressbar'
require 'rbconfig'
require 'zip'
require 'pry'
require_relative 'lib/transformator'
require_relative 'lib/xmlstream'
require_relative 'lib/marc_string'

NAMESPACE={'marc' => "http://www.loc.gov/MARC21/slim"}
ZR_ADDITION=true

#OPTIONS
opts = Trollop::options do
  version "RISM changer 1.0"
  banner <<-EOS
This utility program changes MARCXML nodes according to an YAML file.

Usage:
   marcxml-transform [options]
where [options] are:
  EOS
  opt :rules, "YAML-file with transforming rules", :type => :string, :default => "conf/transform.yaml"
  opt :infile, "Input-Filename", :type => :string
  opt :outfile, "Output-Filename", :type => :string, :default => "out.xml"
end

Trollop::die :infile, "must exist" if !opts[:infile]
source_file=opts[:infile]
transform=YAML.load_file(opts[:rules])
start = 0
ofile=File.open(opts[:outfile], "w")
print transform

if File.exists?(source_file)
  xmlstream = Xmlstream.new(ofile)
  xmlstream.each_record(source_file) do |record|
    delete_flag=false
    tr = Transformator.new(record)
    tr.change_leader
    tr.change_material
    tr.change_collection
    tr.zr_addition_add_isil
    if ZR_ADDITION
      if opts[:rules] =~ /source/
        tr.zr_addition_change_attribution
        tr.zr_addition_prefix_performance
        tr.zr_addition_split_730
        tr.zr_addition_change_243
        tr.zr_addition_change_593_abbreviation
        tr.delete_anonymus
        tr.zr_addition_change_scoring
        tr.zr_addition_remove_empty_linked_fields
      end

      if opts[:rules] =~ /person/
        tr.zr_addition_change_gender
        tr.zr_addition_change_individualize
        tr.zr_addition_change_035
        tr.zr_addition_person_add_profession
      end
    end

    if transform
      transform.each do |entry| 
        entry.each do |k,v|
          # Delete if node not exits
          if !v
            tag=k.split("$")[0]
            code=k.split("$")[1]
            node=record.xpath("//marc:datafield[@tag='#{tag}']", NAMESPACE)
            subfield_node=record.xpath("//marc:datafield[@tag='#{tag}']/marc:subfield[@code='#{code}']", NAMESPACE)
            if node.empty? || subfield_node.empty? || subfield_node.text.strip.empty?
              puts record
              delete_flag=true            
            end
            next if delete_flag
          elsif v=="-"
            tr.remove_subfield(k)
          # Rename datafield
          elsif k.is_tag? && v.is_tag?
            tr.rename_datafield(k, v)
          # Rename subfield
          elsif k.is_tag_with_subfield? && v.is_subfield?
            tag=k.split("$")[0]
            old_sf=k.split("$")[1]
            new_sf=v
            tr.rename_subfield_code(tag, old_sf, new_sf)
          # Move subfield
          elsif k.is_tag_with_subfield? && v.is_tag?
            tr.move_subfield_to_tag(k, v)
          end
        end
      end
    end

    #Sorting tags
    unless delete_flag
      nodes = record.xpath("//marc:datafield", NAMESPACE).remove
      xmlstream.append(record, nodes)
    end
  end
  xmlstream.close
  puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")
else
  puts source_file + " is not a file!"
end

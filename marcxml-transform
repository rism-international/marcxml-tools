#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'nokogiri'
require 'trollop'
require 'ruby-progressbar'
require 'rbconfig'
require 'zip'
require 'pry'
Dir[File.dirname(__FILE__) + '/lib/*.rb'].each {|file| require file }
#require_relative 'lib/transformator'
#require_relative 'lib/xmlstream'
#require_relative 'lib/marc_string'
#require_relative 'lib/oracle_db'
#require_relative 'lib/application_helper'

NAMESPACE={'marc' => "http://www.loc.gov/MARC21/slim"}
ZR_ADDITION=true

#OPTIONS
opts = Trollop::options do
  version "RISM changer 1.0"
  banner <<-EOS
This utility program changes MARCXML nodes according to an YAML file.

Usage:
   marcxml-transform [options]
where [options] are:
  EOS
  opt :rules, "YAML-file with transforming rules", :type => :string, :default => "conf/transform.yaml"
  opt :infile, "Input-Filename", :type => :string
  opt :outfile, "Output-Filename", :type => :string, :default => "out.xml"
end

Trollop::die :infile, "must exist" if !opts[:infile]
source_file=opts[:infile]
transform=YAML.load_file(opts[:rules])
start = 0
ofile=File.open(opts[:outfile], "w")
print transform
total = ApplicationHelper.total(source_file)


bar = ProgressBar.create(title: "Found", :format => "%c of %C Records transformed. -- %a | %B | %p%% %e", total: total, remainder_mark: '-', progress_mark: '#')

if File.exists?(source_file)
  connection = OracleDB.new.connection if !connection
  xmlstream = Xmlstream.new(ofile)
  xmlstream.each_record(source_file) do |record|
    delete_flag=false

    if opts[:rules] =~ /bnf/
      tr = TransformBNF.new(record)
    else
      tr = Transformator.new(record)
    end 

    tr.change_material
    tr.change_collection
    tr.zr_addition_add_isil
    if ZR_ADDITION
      if opts[:rules] =~ /source/
        tr.change_leader
        tr.zr_addition_change_attribution
        tr.zr_addition_prefix_performance
        tr.zr_addition_split_730
        tr.zr_addition_change_243
        tr.zr_addition_change_593_abbreviation
        #tr.delete_anonymus
        tr.zr_addition_change_scoring
        tr.zr_addition_transfer_url
        tr.remove_unlinked_authorities
      end

      if opts[:rules] =~ /bnf/
        tr.change_leader
        tr.zr_addition_change_attribution
        tr.zr_addition_prefix_performance
        tr.zr_addition_split_730
        tr.zr_addition_change_243
        tr.zr_addition_change_593_abbreviation
        #tr.delete_anonymus
        tr.zr_addition_change_scoring
        tr.zr_addition_transfer_url
        tr.change_009
        tr.insert_773_ref
        tr.remove_852_duplicate
        #tr.remove_unlinked_authorities
      end


      if opts[:rules] =~ /person/
        tr.change_leader
        tr.zr_addition_change_gender
        tr.zr_addition_change_individualize
        tr.zr_addition_change_035
        tr.zr_addition_person_add_profession
        tr.zr_addition_person_split_510(connection)
        tr.zr_addition_person_add_670_id(connection)
        tr.zr_addition_change_cataloging_source 
      end
      if opts[:rules] =~ /catalogue/
        tr.change_leader
        tr.zr_addition_catalogue_change_media
        tr.remove_datafield("508")
      end
      if opts[:rules] =~ /institution/
        tr.change_leader
        tr.zr_addition_change_cataloging_source 
      end

    end

    if transform
      transform.each do |entry| 
        entry.each do |k,v|
          # Delete if node not exits
          if !v
            tag=k.split("$")[0]
            code=k.split("$")[1]
            node=record.xpath("//marc:datafield[@tag='#{tag}']", NAMESPACE)
            subfield_node=record.xpath("//marc:datafield[@tag='#{tag}']/marc:subfield[@code='#{code}']", NAMESPACE)
            if node.empty? || subfield_node.empty? || subfield_node.text.strip.empty?
              puts record
              delete_flag=true            
            end
            next if delete_flag
          elsif v=="-"
            tr.remove_subfield(k)
          # Rename datafield
          elsif k.is_tag? && v.is_tag?
            tr.rename_datafield(k, v)
          # Rename subfield
          elsif k.is_tag_with_subfield? && v.is_subfield?
            tag=k.split("$")[0]
            old_sf=k.split("$")[1]
            new_sf=v
            tr.rename_subfield_code(tag, old_sf, new_sf)
          # Move subfield
          elsif k.is_tag_with_subfield? && v.is_tag?
            tr.move_subfield_to_tag(k, v)
          end
        end
      end
    end

    tr.zr_addition_move_852c if opts[:rules] =~ /source/
    
    #Sorting tags
    unless delete_flag
      nodes = record.xpath("//marc:datafield", NAMESPACE).remove
      xmlstream.append(record, nodes)
    end
    bar.increment
  end
  xmlstream.close
  puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")
else
  puts source_file + " is not a file!"
end

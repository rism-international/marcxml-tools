#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'nokogiri'
require 'trollop'
require 'ruby-progressbar'
require 'rbconfig'
require 'zip'
require 'pry'
Dir[File.dirname(__FILE__) + '/lib/*.rb'].each {|file| require file }

NAMESPACE={'marc' => "http://www.loc.gov/MARC21/slim"}
ZR_ADDITION=true

#OPTIONS
opts = Trollop::options do
  version "RISM changer 1.0"
  banner <<-EOS
This utility program changes MARCXML nodes according to an YAML file.

Usage:
   marcxml-transform [options]
where [options] are:
  EOS
  opt :configuration, "YAML-file with transforming rules", :type => :string, :default => "conf/transform.yaml"
  opt :infile, "Input-Filename", :type => :string
  opt :outfile, "Output-Filename", :type => :string, :default => "out.xml"
end

Trollop::die :infile, "must exist" if !opts[:infile]
source_file=opts[:infile]
transform=YAML.load_file(opts[:configuration])
transform_class = transform['Class'] ? Object.const_get(transform['Class']) : Transformator
transform_class.mapping = transform['Mapping']
start = 0
ofile=File.open(opts[:outfile], "w")
#print transform
total = ApplicationHelper.total(source_file)


bar = ProgressBar.create(title: "Found", :format => "%c of %C Records transformed. -- %a | %B | %p%% %e", total: total, remainder_mark: '-', progress_mark: '#')

if File.exists?(source_file)
  #connection = OracleDB.new.connection if !connection
  xmlstream = Xmlstream.new(ofile)
  xmlstream.each_record(source_file) do |record|
    tr = transform_class.new(record)
    #delete_flag=false
    if ZR_ADDITION
      tr.execute_all
    end

    if transform_class.mapping && !transform_class.mapping.empty?
      #transform['Mapping'].each do |entry| 
      transform_class.mapping.each do |entry| 
        entry.each do |k,v|
          # Delete if node not exits
          #if !v
          #  binding.pry
          #  tag=k.split("$")[0]
          #  code=k.split("$")[1]
          #  node=record.xpath("//marc:datafield[@tag='#{tag}']", NAMESPACE)
          #  subfield_node=record.xpath("//marc:datafield[@tag='#{tag}']/marc:subfield[@code='#{code}']", NAMESPACE)
          #  if node.empty? || subfield_node.empty? || subfield_node.text.strip.empty?
          #    puts record
          #    delete_flag=true            
          #  end
          #  next if delete_flag
          if !v && k.is_tag_with_subfield?
            tr.remove_subfield(k)
          elsif !v && k.is_tag?
            tr.remove_tag(k)
          # Rename datafield
          elsif k.is_tag? && v.is_tag?
            tr.rename_datafield(k, v)
          # Rename subfield
          elsif k.is_tag_with_subfield? && v.is_subfield?
            tag=k.split("$")[0]
            old_sf=k.split("$")[1]
            new_sf=v
            tr.rename_subfield_code(tag, old_sf, new_sf)
          # Move subfield
          elsif k.is_tag_with_subfield? && v.is_tag?
            tr.move_subfield_to_tag(k, v)
          end
        end
      end
    end
    #IMPORTANT
    tr.move_852c if opts[:configuration] =~ /source/
    
    #Sorting tags
    if tr.namespace
      nodes = record.xpath("//marc:datafield", NAMESPACE).remove
      xmlstream.append(record, nodes)
    end
    bar.increment
  end
  xmlstream.close
  puts "\nCompleted: "+Time.new.strftime("%Y-%m-%d %H:%M:%S")
else
  puts source_file + " is not a file!"
end
